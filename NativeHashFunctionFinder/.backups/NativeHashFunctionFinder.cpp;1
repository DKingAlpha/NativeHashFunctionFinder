#include "stdafx.h"
#pragma warning(disable:4996)
#include <windows.h>
#include <psapi.h>
#include <stdio.h>
#include <TlHelp32.h>
#include <vector>
#include <stdlib.h>
#include <string>
#include <thread>
#include <tchar.h>
#include <windows.h>
#include <strsafe.h>

// Useful references: http://atom0s.com/forums/viewtopic.php?f=5&t=4&sid=4c99acd92ec8836e72d6740c9dad02ca

// Retrieve the system error message for the last-error code
void ErrorExit(LPTSTR lpszFunction)
{
	LPVOID lpMsgBuf;
	LPVOID lpDisplayBuf;
	DWORD dw = GetLastError();

	FormatMessage(
		FORMAT_MESSAGE_ALLOCATE_BUFFER |
		FORMAT_MESSAGE_FROM_SYSTEM |
		FORMAT_MESSAGE_IGNORE_INSERTS,
		NULL,
		dw,
		MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
		(LPTSTR)&lpMsgBuf,
		0, NULL);

	// Display the error message and exit the process

	lpDisplayBuf = (LPVOID)LocalAlloc(LMEM_ZEROINIT,
		(lstrlen((LPCTSTR)lpMsgBuf) + lstrlen((LPCTSTR)lpszFunction) + 40) * sizeof(TCHAR));
	StringCchPrintf((LPTSTR)lpDisplayBuf,
		LocalSize(lpDisplayBuf) / sizeof(TCHAR),
		TEXT("\n%s failed with error %d: %s"),
		lpszFunction, dw, lpMsgBuf);
	_tprintf(TEXT("%s\n"), (LPCTSTR)lpDisplayBuf);

	LocalFree(lpMsgBuf);
	LocalFree(lpDisplayBuf);
	ExitProcess(dw);
}


DWORD GetProcessByName(WCHAR* name)
{
	DWORD pid = 0;

	HANDLE snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
	PROCESSENTRY32 process;
	ZeroMemory(&process, sizeof(process));
	process.dwSize = sizeof(process);

	if (Process32First(snapshot, &process))
	{
		do
		{
			if (wcsstr(process.szExeFile, name) != NULL)
			{
				pid = process.th32ProcessID;
				break;
			}
		} while (Process32Next(snapshot, &process));
	}

	CloseHandle(snapshot);

	if (pid != 0)
	{
		return pid;
	}

	return NULL;
}


int main()
{
	__int64 hash; //  , result;
	printf("enter Native Hash (or 0 for GET_PLAYER_PED)\n");
	scanf("%llx", &hash);
	if (!hash) {
		hash = 0xC834A7C58DEB59B4;
	}

	DWORD PPID = GetProcessByName(TEXT("GTA5"));
	if (!PPID) {
		printf("Failed to GetProcessByName(GTA5)\n");
		exit(1);
	}
	else {
		printf("Found GTA5.exe, PID: %lu\n", PPID);
	}

	SYSTEM_INFO si;
	ZeroMemory(&si, sizeof(SYSTEM_INFO));
	GetSystemInfo(&si);
	char* buf = new char[si.dwPageSize];
	HANDLE hProcess = OpenProcess(PROCESS_VM_OPERATION | PROCESS_VM_READ | PROCESS_QUERY_INFORMATION, FALSE, PPID);
	if (!hProcess) 
		ErrorExit(TEXT("OpenProcess"));
	
	printf("Scanning process for hash 0x%016llx\n\n", hash);
	auto addr_min = (__int64)si.lpMinimumApplicationAddress;
	auto addr_max = (__int64)si.lpMaximumApplicationAddress;

	auto found = 0;

	// Loop the pages of memory of the application.. 
	while (addr_min < addr_max)
	{
		MEMORY_BASIC_INFORMATION mbi = { 0 };
		if (!VirtualQueryEx(hProcess, (LPCVOID)addr_min, &mbi, sizeof(mbi)))
			ErrorExit(TEXT("VirtualQueryEx"));

		// Determine if we have access to the page.. 
		if (mbi.State == MEM_COMMIT && ((mbi.Protect & PAGE_GUARD) == 0) && ((mbi.Protect & PAGE_NOACCESS) == 0))
		{
			// 
			// Below are flags about the current region of memory. If you want to specifically scan for only 
			// certain things like if the area is writable, executable, etc. you can use these flags to prevent 
			// reading non-desired protection types. 
			// 

			auto isCopyOnWrite = ((mbi.Protect & PAGE_WRITECOPY) != 0 || (mbi.Protect & PAGE_EXECUTE_WRITECOPY) != 0);
			auto isExecutable = ((mbi.Protect & PAGE_EXECUTE) != 0 || (mbi.Protect & PAGE_EXECUTE_READ) != 0 || (mbi.Protect & PAGE_EXECUTE_READWRITE) != 0 || (mbi.Protect & PAGE_EXECUTE_WRITECOPY) != 0);
			auto isWritable = ((mbi.Protect & PAGE_READWRITE) != 0 || (mbi.Protect & PAGE_WRITECOPY) != 0 || (mbi.Protect & PAGE_EXECUTE_READWRITE) != 0 || (mbi.Protect & PAGE_EXECUTE_WRITECOPY) != 0);

			// Dump the region into a memory block.. 
			auto dump = new unsigned char[mbi.RegionSize + 1];
			memset(dump, 0x00, mbi.RegionSize + 1);

			printf("\r0x%llx: %04x", (__int64)mbi.BaseAddress, mbi.Protect); // mbi.Protect & 0x100);
			if (!ReadProcessMemory(hProcess, mbi.BaseAddress, dump, mbi.RegionSize, NULL))
				ErrorExit(TEXT("ReadProcessMemory")); // "Failed to read memory of location : %08X\n", mbi.BaseAddress);

			__int64 Address = (__int64)mbi.BaseAddress;
			for (SIZE_T x = 0; x < mbi.RegionSize - 8; x += 4, Address += 4)
			{
				if (*(__int64*)(dump + x) == hash) 
				{
					// Address == ((__int64)mbi.BaseAddress + x)
					printf_s("\nFound hash at address: 0x%12llx\n", Address);
					if (x >= 0x40) {
						__int64 result = *(__int64*)(dump + x - 0x40);
						printf_s("Pointer to Native Function is at: 0x%12llx\n", Address - 0x40);
						printf_s("Native Function Address: %012llx\n", result);
					}
					else {
						printf("\nNative Function Address is on previous page... woops!");
					}
					found++;
				}
			}

			// Cleanup the memory dump.. 
			delete[] dump;
		}

		// Step the current address by this regions size.. 
		if (found) break;
		addr_min += mbi.RegionSize;
	}

	printf_s("Found %d results!\n", found);
}
