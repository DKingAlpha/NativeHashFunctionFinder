#include "stdafx.h"
#pragma warning(disable:4996)
#include <windows.h>
#include <psapi.h>
#include <stdio.h>
#include <TlHelp32.h>
#include <vector>
#include <stdlib.h>
#include <string>
#include <thread>
#include <tchar.h>
#include <windows.h>
#include <strsafe.h>

// Useful references: http://atom0s.com/forums/viewtopic.php?f=5&t=4&sid=4c99acd92ec8836e72d6740c9dad02ca


using namespace std;

void ErrorExit(LPTSTR lpszFunction)
{
	// Retrieve the system error message for the last-error code

	LPVOID lpMsgBuf;
	LPVOID lpDisplayBuf;
	DWORD dw = GetLastError();

	FormatMessage(
		FORMAT_MESSAGE_ALLOCATE_BUFFER |
		FORMAT_MESSAGE_FROM_SYSTEM |
		FORMAT_MESSAGE_IGNORE_INSERTS,
		NULL,
		dw,
		MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
		(LPTSTR)&lpMsgBuf,
		0, NULL);

	// Display the error message and exit the process

	lpDisplayBuf = (LPVOID)LocalAlloc(LMEM_ZEROINIT,
		(lstrlen((LPCTSTR)lpMsgBuf) + lstrlen((LPCTSTR)lpszFunction) + 40) * sizeof(TCHAR));
	StringCchPrintf((LPTSTR)lpDisplayBuf,
		LocalSize(lpDisplayBuf) / sizeof(TCHAR),
		TEXT("\n%s failed with error %d: %s"),
		lpszFunction, dw, lpMsgBuf);
	_tprintf(TEXT("%s\n"), (LPCTSTR)lpDisplayBuf);

	LocalFree(lpMsgBuf);
	LocalFree(lpDisplayBuf);
	ExitProcess(dw);
}


DWORD GetProcessByName(WCHAR* name)
{
	DWORD pid = 0;

	HANDLE snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
	PROCESSENTRY32 process;
	ZeroMemory(&process, sizeof(process));
	process.dwSize = sizeof(process);

	if (Process32First(snapshot, &process))
	{
		do
		{
			if (wcsstr(process.szExeFile, name) != NULL)
			{
				pid = process.th32ProcessID;
				break;
			}
		} while (Process32Next(snapshot, &process));
	}

	CloseHandle(snapshot);

	if (pid != 0)
	{
		return pid;
	}

	return NULL;
}


int main()
{
	__int64 hash; //  , result;
	printf("enter Native Hash (or 0 for GET_PLAYER_PED)\n");
	scanf("%llx", &hash);
	if (!hash) {
		hash = 0xC834A7C58DEB59B4;
		// hash = 0xB459EB8DC5A734C8;
	}

//	__int64 Address = 0x00000000;
//	INT i;
	CHAR *MemoryBuff = new CHAR[4096];
	DWORD PPID = GetProcessByName(TEXT("GTA5"));
	if (!PPID) {
		printf("Failed to GetProcessByName(GTA5)\n");
		exit(1);
	}
	else {
		printf("Found GTA5.exe, PID: %lu\n", PPID);
	}

	SYSTEM_INFO si;
	ZeroMemory(&si, sizeof(SYSTEM_INFO));
	GetSystemInfo(&si);
	char* buf = new char[si.dwPageSize];
//  HANDLE hProc = OpenProcess(PROCESS_VM_READ | PROCESS_QUERY_INFORMATION,FALSE,GetCurrentProcessId());
//  HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, PPID);
	HANDLE hProcess = OpenProcess(PROCESS_VM_OPERATION | PROCESS_VM_READ | PROCESS_QUERY_INFORMATION, FALSE, PPID);
	if (!hProcess) {
		printf("Failed to OpenProcess(PROCESS_ALL_ACCESS, FALSE, %lu)", PPID);
		exit(1);
	}
		
	printf("Scanning process for hash 0x%016llx\n\n", hash);
	auto addr_min = (__int64)si.lpMinimumApplicationAddress;
	auto addr_max = (__int64)si.lpMaximumApplicationAddress;

#define FASTSUCKED 1
#ifdef FASTSUCKED
	auto found = 0;

	// Loop the pages of memory of the application.. 
	while (addr_min < addr_max)
	{
		MEMORY_BASIC_INFORMATION mbi = { 0 };
		if (!VirtualQueryEx(hProcess, (LPCVOID)addr_min, &mbi, sizeof(mbi)))
		{
			ErrorExit(TEXT("VirtualQueryEx"));
			break;
		}

		// Determine if we have access to the page.. 
		if (mbi.State == MEM_COMMIT && ((mbi.Protect & PAGE_GUARD) == 0) && ((mbi.Protect & PAGE_NOACCESS) == 0))
		{
			// 
			// Below are flags about the current region of memory. If you want to specifically scan for only 
			// certain things like if the area is writable, executable, etc. you can use these flags to prevent 
			// reading non-desired protection types. 
			// 

			auto isCopyOnWrite = ((mbi.Protect & PAGE_WRITECOPY) != 0 || (mbi.Protect & PAGE_EXECUTE_WRITECOPY) != 0);
			auto isExecutable = ((mbi.Protect & PAGE_EXECUTE) != 0 || (mbi.Protect & PAGE_EXECUTE_READ) != 0 || (mbi.Protect & PAGE_EXECUTE_READWRITE) != 0 || (mbi.Protect & PAGE_EXECUTE_WRITECOPY) != 0);
			auto isWritable = ((mbi.Protect & PAGE_READWRITE) != 0 || (mbi.Protect & PAGE_WRITECOPY) != 0 || (mbi.Protect & PAGE_EXECUTE_READWRITE) != 0 || (mbi.Protect & PAGE_EXECUTE_WRITECOPY) != 0);

			// Dump the region into a memory block.. 
			auto dump = new unsigned char[mbi.RegionSize + 1];
			memset(dump, 0x00, mbi.RegionSize + 1);
			printf("\r0x%llx: %04x", (__int64)mbi.BaseAddress, mbi.Protect); // mbi.Protect & 0x100);
			if (!::ReadProcessMemory(hProcess, mbi.BaseAddress, dump, mbi.RegionSize, NULL))
			{
				ErrorExit(TEXT("ReadProcessMemory")); // "Failed to read memory of location : %08X\n", mbi.BaseAddress);
				// ReadProcessMemory failed with error 299: Only part of a ReadProcessMemory or WriteProcessMemory request was completed.
			}

			// auto Address = mbi.BaseAddress;
			__int64 Address = (__int64)mbi.BaseAddress;
			for (SIZE_T x = 0; x < mbi.RegionSize - 8; x += 4, Address += 4)
			{
				if (*(__int64*)(dump + x) == hash) 
				{
					// ((__int64)mbi.BaseAddress + x) === Address
					printf_s("\nFound hash at address: 0x%08llx\n", Address);
					if (x >= 0x40) {
						printf_s("Pointer to Native Function is at: 0x%12llx\n", Address - 0x40);
						__int64 result;
						result = *(__int64*)(dump + x - 0x40);
						// ReadProcessMemory(hProcess, (LPVOID)(Address - 0x40), &result, sizeof(result), 0);
						printf_s("Native Function Address: %012llx\n", result);
					}
					else {
						printf("\nNative Function Address is on previous page... woops!");
					}
					found++;
				}
			}

			// Cleanup the memory dump.. 
			delete[] dump;
		}

		// Step the current address by this regions size.. 
		addr_min += mbi.RegionSize;
	}

	printf_s("Found %d results!\n", found);

#else
	for (__int64 i = addr_min; i < addr_max /* 0x9FFF9840 */; i+= si.dwPageSize)
	{
		void* baseOffs = (void*)(i);
		MEMORY_BASIC_INFORMATION mbi;
		ZeroMemory(&mbi, sizeof(MEMORY_BASIC_INFORMATION));

		if (VirtualQueryEx(hProcess, baseOffs, &mbi, sizeof(MEMORY_BASIC_INFORMATION)) == 0)
			ErrorExit(TEXT("VirtualQueryEx"));

		// TODO:
		// http://stackoverflow.com/questions/12122323/readprocessmemory-fails-on-some-pages-getlasterror-299
		// use VirtualProtectEx to temporarely remove the flag
		// See also: http://stackoverflow.com/questions/20068219/readprocessmemory-on-a-64-bit-proces-always-returns-error-299

		__int8 hashByte = hash & 0xff;
		SIZE_T numByteWritten = 0;
		if (mbi.State == MEM_COMMIT)
		{
			printf("\r0x%08llx: %04x", i, mbi.Protect); // mbi.Protect & 0x100);

			if (!ReadProcessMemory(hProcess, baseOffs, buf, si.dwPageSize, &numByteWritten))
				ErrorExit(TEXT("ReadProcessMemory"));

			/* if (!ReadProcessMemory(hProcess, (LPVOID)Address, (LPVOID)MemoryBuff, 4096, NULL)) {
				ErrorExit(TEXT("ReadProcessMemory"));
			}  */

			MemoryBuff = buf;
			Address = (__int64)baseOffs;
			for (SIZE_T p = 0; p < numByteWritten; p++)
			{
				// Address++;
				MemoryBuff++;

			//	if (*MemoryBuff == hashByte)
				// Unhandled exception at 0x6BC13AA8 (vcruntime140d.dll) in ConsoleApplication1.exe: 0xC0000005: Access violation reading location 0x002EF049.		
				if (memcmp(MemoryBuff, &hash, sizeof(hash)) == 0)
				{
					printf("Yay\n");
					ErrorExit(TEXT("We Found It!"));
					ReadProcessMemory(hProcess, (LPVOID)(Address - 0x40), &result, sizeof(result), 0);
					printf("\nresult:%llX\n", result);
					exit(0);
				}

			}
			// MemoryBuff = MemoryBuff - numByteWritten; // Not that it really matters
		}
	}

#endif // SLOW
}